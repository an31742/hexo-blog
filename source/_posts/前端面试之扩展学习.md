---
title: 前端面试之扩展学习
date: 2022-06-20 16:56:54
tags: 前端升级
---


#### 第一天

### 浏览器如何渲染页面

###### 字节流解码   

浏览器通过编码嗅探算法将字节流数据转字符数据 

###### 输入流预处理  

在进入解析还要进行一些预处理生成规范的的字符流  将换行符转换成统一格

###### 令牌化

讲字符串转换成令牌token  不同状态下接收同一字符产生不同的结果

将字符串转化成html 

###### 构建dom树

当树构建接收某个令牌时就会创建该令牌对应的dom元素，并将该元素插入到dom数中

### 函数为什么是一等公民

###### this关键字

this指向函数执行上下文的对象

其次这个对象指向调用它的对象，如果调用它的不是对象或者不存在，则会指向全局对象

```js
//代码1

let o={
    fn(){
        console.log(this)
    }
}
this指向对象o
//代码2
o.fn(){
class A{
  fn(){
   console.log(this)
  }
}
}

  let a=new A()  
  a.fn()
this指向实例a
  //代码3
    function fn(){
     console.log（this）
    }
     fn()
this指向全局对像


```



箭头函数和普通函数的区别

+ 箭头函数访问arguments对象会报错
+ 不能用做构造器，表现：不能通过new关键字创建一个新的函数
+ 默认不会创建prototype原型属性
+ 不能用Generator()函数，不能使用yeild

###### 函数的转换

隐式转换函数

ToString()会在打印函数的时候调用  比如console

valueOf()会获取函数原始值得时候调用  比如加法操作

###### 什么是原型和原型链

原型就是对象的属性

包括被称为隐式原型的  _proto_   的隐式属性和显示原型的prototype的显示属性

隐式原型在创建实例的时候自动指向构造函数的原型

```js
let a={}
a.__proto__===Object.prototype  //true
let b=new Object()
b.__proto__===a.__proto__

```

显示原型指向构造函数的自身

````js
function fn(){}
fn.prototype.constructor=fn
````

```
let parent ={code:'9',name:'李华'}
let child ={__proto__:parent,name:'王明'}

console.log(parent.prototype ) //undefined
console.log(child.code)    //9
console.log(child.name)  //李华
child.hasOwnProperty(child.code) //false
child.hasOwnProperty(child.name)//true

```

###### new操作符实现了什么

```
function F (init){}
let f= new F(arges)
```

1.创建了一个临时的空的对象 fn

我们为表述方便成为fn，让fn对象的隐式原型指向F的显示原型

2.执行函数F()

讲this指向函数fn，并传入参数args，得到执行结果result

3.判断上一个执行结果result，如果执行结果为非空对象，则返回result。否则返回fn

```js
let fn =Object.create(F.prototype)
let obj=fn.apply(fn,args)
let f=obj && type.obj==='Object' ?obj:fn
```

手写一个new的实现过程

###### 怎么通过原型链实现多层继承

```
function A(){
}

A.prototype.a=function (){
  return 'a'
}
function B(){}
B.prototype=new A()
B.prototype.b=function (){
  return 'b'
}
let c=new B
c.b() //b
c.a() //a
```

###### typeOf和instanceOf

typeOf用来获取一个值得类型

instanceOf用来检测构造函数的显示原型属性prototype

###### 作用域

作用域是指的赋值和取值操作的执行范围

通过作用域的机制可以有效的防止，变量，函数的重复定义，以及控制他们的可访问性

浏览器和Node.JS对于作用域处理的不同



|        | 全局作用域                           | 模块级别的作用域                        |
| ------ | ------------------------------------ | --------------------------------------- |
| node   | 挂载到global上                       | common.js模块机制提供了模块级别的作用域 |
| 浏览器 | 将为主动生命的变量提升到全局作用域上 | es6之前浏览器不提供模块级别的作用域     |

###### 命名提升

在使用var关键字的声明变量以及创建函数的时候，JavaScript在解释执行的时候都会将声明的内容提升到作用域顶部这种机制成为命名提升

变量命名提升在同级或者子级作用域中在变量声明之前引用。仅限var关键字得到的是未赋值的变量 undefined

###### 闭包

在函数内部访问外部作用域就会产生闭包

闭包允许将函数与其所操作的数据关联起来，这种关联不止是跨作用的引用也可以实现数据与函数的隔离

```js
for(var=i,i<5,i++){
setTimeOut(()=>{
console.log(i)
},1000*1)
}

//每个一秒打印数字1到5但是现在打印都是5

原因：for循环和命名提升i共享同一个变量  
修复：将var替换成let变成块级作用域

```



#### 第二天

### 为什么代码没有按照循序执行

###### 异步和同步

| 同步                                             | 异步                                                         |
| ------------------------------------------------ | ------------------------------------------------------------ |
| 立即执行操作并等待返回结果再继续执行同步是阻塞的 | 操作和结果在时间上分开来在当下执行操作在未来某个时刻返回结果，在这个返回结果的过程中程序将继续执行后面的代码 |

###### 异步原理

单线程实现异步

把一些操作交给其他线程处理，然后采用一种事件循环的操作机制来处理返回结果

```js
//用这段代码模仿事件循环，事件轮询
let eventLoop=[]
let event
while(){
    if(eventLoop.length>0){
   event=eventLoop.shif()
   try(){
event()
}catch(){
reportError()
}
}
}
```

事件队列采用先进先出的事件进行  如果有比较紧急的事件也要等待按照优先级来进行

promise的局限性

promise一旦创建就会被立即执行，无法从外部停止，比如无法取消超时，或者消耗性能的异步调用。容易导致资源浪费

promise处理问题都是一次性的，因为promise只能resolve和reject一次。所以面对持续响应就力不从心

###### 模块化管理和规范

**es6模块**

在node.js使用es6模块需要将文件后缀名改为.mjs

值引用：通过export语句输出的接口，与其对应的值动态绑定关系，即通过该接口取到模块内部实时的值。可以简单理解为变量浅拷贝。

es6对于文件的声明有严格的要求：

1.必须是在文件的首部声明 在vue中就是script标签下

2.不允许使用变量或者表达式

3.不允许被嵌套其他的语句中  表达式

import支持动态引入模块

```js
export let a=''
setTime(()=>{
 a='a'
 },500)
 
 import {a} from './a.js'
 console.log(a) //''
 setTime(()=>{
 console.log(a)
 },1000)  //a  一秒过后拿到已经赋值的   所以是浅拷贝
```



**commonjs**

commonjs规定每个文件都是一个模块，有独立的作用域，每个模块内部都有一个moudle对象，代表当前模块通过他导出api

id  模块识别符通常带有绝对路径的文件模块名

fileName 模块的文件名，带有绝对路径

loaded  返回一个布尔值，代表模块已经加载完成

parent 返回一个对象表示调用该模块的模块

children 返回一个数组表示该模块要用到的其他模块

exports表示该模块对外输出的值

调用通过require。

值拷贝：一旦输出一个值，模块内部的值就影响不到这个值，可以理解为变量深拷贝。

~~~js
let a=''
setTime(()=>{
 a='a'
 },500)
 
 module.exports=a
 
 let a=require('./a.js')
 
 console.log(a) //''
 setTime(()=>{
 console.log(a)
 },1000)  //''  一秒过后还是空 所以是深拷贝
 
~~~



**AMD**

全局函数define  define(id? ,dependencise?,factory?)

```
define('alpha',['require','exports','beta'],function(require,exports'beta){
  exports.verb=function(){
   return beta.verb()
  }

})
```

异步加载

**CMD**

也是通过全局函数define   define(facyory)

不需要在定义的时候，声明依赖，可以在模块执行的时候动态加载。cmd同时支持同步加载和异步加载

**UMD**

并不是模块管理规范而是带有前后端同构思想的模块封装管理工具

UMD可以在合适的环境选择对应的模块管理规范

#### 第三天

###进程和线程

进程操作系统进行资源分配和调度的基本单位

线程是操作系统进行运算的最小单位

一个程序最少有一个进程，一个进程至少有一个线程

线程需要进程的启动和管理。单线程的进程同一时间只能执行一个任务

进程的资源都是独享，多线程没有分配独立的资源，数据都是共享的

进程中任意线程的奔溃都会导致整个进程的奔溃，会牵连到进程的其他线程

多线程更轻量，多进程更安全

**浏览器的进程**

负责界面的显示，处理用户事件，处理子进程

**GPU进程**

处理其他线程的GPU任务，比如来自渲染进程的或扩展程序的css3动画效果。

特性：利用GPU硬件来加速渲染

**network service 进程**

负责页面的网路资源加载，网络进程会将请求到的资源交给渲染进程处理

**v8代理解析工具进程**

Chrome支持JavaScript来写链接代理服务脚本，称为pc代理脚本

**渲染进程**

渲染进程并不是唯一的，浏览器会为每个标签页单独启动一个渲染进程。

渲染进程是将html，css，JavaScript转换成用户与之交互的网页

每个渲染进程都会启动单独的JavaScript引擎线程和渲染引擎线程

**扩展程序进程**

主要负责每一个插件的运行

多进程在稳定性和安全性具有优势，对于复杂的应用我们采取服务化的设计。将功能模块单独拆分进程来提供服务。合理利用GPU进程加速渲染

### 深入理解HTTP协议

###### tcp建立链接三次握手四次挥手

|            | 服务端                                                       | 客户端                                                       |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 第一次握手 | listen状态      服务端知道客户端具有发送能力                 | closed状态 发送给服务端syn报文并告诉序列号ISN  发送完处于syn_SEND状态 |
| 第二次握手 | 服务端收到客户端的syn报文后会以自己的syn作为应答，并且制定自己的初始化序列号ISN，将客户端isn+1作为ack的值。表示自己收到了  服务处于SYN_SEND | 让客户端知道服务端具有接收和发送能力                         |
| 第三次握手 | 服务器收到客户端的ISN+1 也处于established状态  此时双方成功建立链接  服务端知道客户端接收了自己的信息 | 当客户端收到服务端的SYN的值后，发送ack报文，将服务端ISN+1表示收到服务端的ack，客户端处于established状态 |

###### tcp断开链接四次挥手

|            | 服务端                                                    | 客户端                                                       |
| ---------- | --------------------------------------------------------- | ------------------------------------------------------------ |
| 第一次挥手 | 挥手之前established                                       | 挥手之前established   发送fin报文用来关闭客户端到服务端的数据  现在处于fin_wait1状态 |
| 第二次挥手 | 收到fin报文  发送ack报文   此时服务端处  于close_wait状态 | 客户端处于fin_wait2状态                                      |
| 第三次挥手 | 如果客户端同意关闭链接会发送fin报文                       |                                                              |
| 第四次挥手 | 服务端接收ack报文也处于closed状态                         | 客户端接收服务端的fin报文，发送ack报文客户端处于closed状态   |

###### http3将tcp链接变成UDP链接

特点：传输数据不需要建立链接，可以同时发送多个数据包。缺点没有确认机制保证对方一定能收到数据

###### 证书机制

只有服务端生成密钥对，将公钥分发给建立链接的客户端

把公钥放到一个证书里，该证书包含服务端信息，需要有一个可信的第三方进行签名

#### 第四天

### 如何让浏览器更快的加载网络资源

1，减少响应内容的大小使用，gzip算法压缩响应体内容和http/2压缩头部功能

2，使用缓存（数据库缓存，服务端缓存，CDN缓存，浏览器缓存）

###### 浏览器缓存

保证被使用的缓存与服务端最新的资源保持一致

http支持的缓存策略：强缓存和协商缓存

**强制缓存**

在浏览器加载请求资源的时候，先直接在缓存中查找请求结果，，如果不存在然后直接向服务端发起请求

1.expires通过响应头部expires设置缓存时间 

第一次请求时服务端设置expires时间，当浏览器再次发送请求时如果早于expires时间直接缓存，反之再次发送请求

2.Cache-Control

no-cache:表示使用协商缓存，每次使用缓存前必须向服务端确认缓存资源是否更新

no-store:禁止浏览器及其中间缓存存储响应内容

pubilc：共有缓存表示可以被代理服务器缓存，可以被多个用户共享

private：私有缓存表示不可以被代理服务器共享，不可以被多个用户共享

max-age：以秒为单位，表示缓存的有效时间

must-revalidate：当缓存过期时需要去服务端校验缓存的有效性

可以组合使用

**协商缓存**

不在指定缓存的有效时间，而是直接发送请求到服务端确认是否缓存更新

控制缓存的难题将浏览器转移给了服务端

1.last-modified 和if-modified-since

通过响应字段last-modified和请求头部字段对比if-modified-since。资源更新的时间

第一次浏览器请求服务端在响应加上last-modified字段，这个字段有资源修改时间

浏览器再次请求需要在请求头部加上if-modifiled-since字段，内容是对应服务器之前请求的修改时间

有两个缺点：

精度：这个是以秒为单位，在一秒内发生变化就没有精度

准度：问题如果在文件被修改又还原，文件本身没问题，但文件本身没问题，也会重新返回重复内容

2.Etag和if-None-Match

响应头部：Etag

请求头部：if-None-match

浏览器第一次请求在服务器再返回加上Etag字段，字段值为该资源的哈西值

当浏览器再次和服务端请求资源时，在请求头上加上if-None-Match。值为之前响应头部的Etag的值

如果没变化就会服务端返回304，否则就正常返回资源。无论是否返回都会将计算的哈希值放到响应的头部中

缺点：计算成本比较大，精度有误差

**serviceworker**

浏览器独立于网页运行的脚本，浏览器与服务器的代理服务器。主要是实现离线缓存

### 浏览器同源策略和跨域

源：是指的是协议，端口，主机名，

当一个源访问另一个源的时候就会产生跨源

最常见的跨源就是域名不同就是跨域

跨域资源共享是ajax设置的一种跨域机制，可以在服务端允许的情况进行跨域，通过HTTP响应头来告诉服务端是否允许当前域的脚本进行跨域。

跨域资源共享：

**请求方法get，post，head**

简单请求只能有以下字段：

Accept 浏览器能够接受的响应内容

Accept-Language 浏览器能够接受的浏览器自然语言列表

Content-type  请求对应的类型

Content-language  浏览器希望采用的自然语言

Save-Data 浏览器是否希望减少数据传输 

**非简单请求**

浏览器会先发出一个预检请求Preflight

这个预检请求添加了options方法，并且会添加一个请求头部字段  Access-Control-Request-Method,值为跨域请求所使用的的请求方法

**请求跨域解决方案**

JSONP：就是把json数据填充到一个回调函数当中

依赖script标签跨域引用js文件不会受浏览器同源策略的影响

```js
实现方式：
let url ='http://www.baidu.com'

var srcipt=document.createElement('script')
srcipt.setAttribute('type','text/javascript')
scrpit.src=url
document.body.appendChild(script)
```

缺点：只能是get 限制了参数大小和类型。请求过程无法终止，无法捕获服务端返回的异常信息

websocket：是html5规范提出的应用层全双工协议，适用于浏览器与服务端实时通信。

全双工：从服务端到客户端，和从客户端到服务端

```
var ws=new websocket("ws://b.com")
ws.onopen=function(){
// ws.send(...)
}
ws.onmessage=function(e){
// console.log(e.data)
}
```

代理转发

跨域是为了突破浏览器同源策略的限制

在服务服务端进行跨域，这种在服务端设置的代理称为反向代理

在客户端使用的代理称为正向代理。主要是用来代理客户端的请求。用户使用必须配置代理服务。

```js
webpack.config.js
module.exports={
 devServer:{
   proxy:{
   'api':'http://locahost:3000'
   }
  
  }

}

nux
location/api{
    procy_pass http://loachost:300
}
```

页面跨域解决方案

使用iframe跨域解决方案

```

//父页面通过这个跨域传递参数
var child=window.open('https://www.baidu.com')
child.postMessage('hi','https://www.baidu.com')  //发送这个函数给子页面

//父页面监听子页面
window.opener.postMessage('hello','https//lagou.com')



//子页面监听就可以得到父页面hi
Window.addEventListener('message',function(e){
  console.log(e.data)
 },false)
```

改域

主域名相同子域名不同的情况下可以通过修改document.domain的值来进行改域

```js
页面的地址是：https://www.lagou.com/parent.html
当前页面有一个iframe，src是https://kaiwu.lagou.com/child.html

只要吧父地址https://www.lagou.com/parent.html和子地址的https://kaiwu.lagou.com/child.html。通过document.domain设置相同的域名就可以跨域通信，还可以共享cookie。只能设置成父域才有效果
```

### 组件

组件就是基于视图的模块

组件的任务就是将数据渲染到视图并监听用户在视图上的操作

### 路由

hash值得变化不会浏览器发送请求hash值是url #后面的内容。通过location.hash读写

### 组件之间的通信

### 代码是如何编译的

**校验配置项**

是通过validateSchema()函数来实现的，这个函数内部其实是调用Schema-utils模块来实现validate()

validate通过支持jsonSchema规则来校验json对象。jsonSchema规则保存在SchemaWebpackOptions.json中对应WebpackOptionsSchema变量。

**创建编译器**

创建编译操作是在comiler.complie()中函数调用crateComplier函数来实现的。该函数会返回一个complier实例

调用四种钩子

SyncHook 当钩子触发时会依次调用钩子队列中的回调函数

SyncBialHook 当钩子触发时会依次调用钩子队列中的回调函数，如果有返回值的函数则停止继续调用

AsyncSeriesHook  异步串行钩子 当回调函数有异步回调函数，会等其执行完在执行剩余的回调函数

AsyncparallelHook异步并行钩子 可以异步执行钩子队列中所有异步回调函数  

使用钩子引用插件进行初始化

**执行编译**

调用compiler函数标志着进入执行编译阶段 

#### 第五天

### 如何搭建前端项目

代码规范：

少用全局变量

高内聚，低耦合

遵循单一原则

拥有注释

**ESlint**

是通过一个叫verify()函数来实现的，该函数有两个必传参数，要验证源码的文本和一个配置对象

### 性能优化

基于对用户的对页面的体验的优化叫做性能优化

衡量前端的性能指标

**首屏绘制**FP

从开始加载浏览器首次绘制像素到屏幕的时间，也就是页面首次在屏幕发生视觉变化的时间，俗称白屏时间

```js
performance.getEntriesByType('paint')[0]

{
    duration:'' //绘制时间
    name:'' //绘制名称
    enterType：'' //绘制类型
    startTime:''  //开始时
    }
```

**首屏内容绘制**FCP

```js
performance.getEntriesByType('paint')[1]   FCP

{
    duration:'' //绘制时间
    name:'' //绘制名称
    enterType：'' //绘制类型
    startTime:''  //开始时
    }
```

**可交互时间**

网页在视觉上已经渲染出浏览器可以响应用户的操作

耗时超过50ms执行完成的

随后网络精磨时间达到5s

静默时间：

请求树不超过5个

排除失败的请求资源和未使用get请求的

**总阻塞时间**TBT

阻塞用户响应的所有时间  阻塞任务

**最大内容绘制**

视口内可见的最大图像或文本块的绘制时间

**统计方式**

平均值统计

**百分数统计**

**加载性能优化**

做减法：

采用gzip压缩，

使用缓存

使用雪碧图

做除法：http2多路服用，懒加载，把script标签放到body底部

**渲染性能优化**

做减法：

减少重排与重绘

减少请求次数

防抖操作

减少DOM操作

做除法：

骨架屏

使用web worker

将同步视图的进行拆分可调用可暂停

**前端如何成为黑客攻击方式的**

跨站脚本：

反射型  （非持久型XSS  攻击）

存储型

DOM型

xss攻击防御手段：对参数和请求体进行数据校验，后端进行转移存储，不要使用动态执行的方法，避免前端访问cookie

**跨站请求伪造**

CSRF请求伪造

CSRF防御手段：

判断refer来拒绝不受信任的源发送请求

在地址栏中添加其他头部字段，

通过用户确认来攻击

**点击劫持**

创建一个网页利用iframe包含目标网站,在网页诱导用户点击特定的按钮，当用户点击网页上的按钮时，实际点击的是目标网站的按钮

防御：设置响应头字段X-frame—OPtions来告诉浏览器允许哪些域名引用当前页面  值有下面三个  

​          DENY 不允许在iframe中引用

​             SameORIGIN 表示该页面可以在相同的iframe域名中引用

​            ALLOW-FROM[url] 该iframe可以在指定来源的iframe中引用

### 数据结构

JavaScript通过fixedArry和HashTable实现数组

栈只能尾部操作进行添加和删除

队列可以头部和尾部进行操作，只能头部插入尾部删除  先进先出

浏览器的前进和后退就是栈，V8函数执行结构也是栈  先进后出

链表是在存储空间具有一定优势的线性结构  使用指针链接元素节点

树就是有限节点组成一个具有层次关系的集合

分类：二叉树，满二叉树，有序树

**深度遍历**：

先序遍历：根节点-->左子树-->右子树

中序遍历：左子树-->根节点-->右子树

后序遍历：左子树-->右子树-->根节点



 

 





​	     








