---
title: 前端面试之gulp-webpack
date: 2022-07-28 01:13:53
tags: 前端面试
---

# gulp

* 流处理：Gulp是一个基于流的构建系统
* 没有产生中间文件：使用Gulp的优势就是利用流的方式进行文件的处理，通过管道将多个任务和操作连接起来，因此只有一次I/O的过程，流程更清晰，更纯粹。
* Gulp去除了中间文件，只将最后的输出写入磁盘，整个过程因此变得更快。

* 常用插件：
```
gulp-autoprefixer:css前缀
gulp-cssnano：压缩
gulp-less：less

gulp-uglify：压缩JS
gulp-babel：语法转换
```

# webpack

* 打包原理：所有的依赖被打包为一个JS文件，通过代码分割成单元片段并按需加载。
* 引入： 以 commonJS 的形式来书写脚本，但对 AMD/CMD 的支持也很全面，
* 所有静态资源模块化；
* 扩展性强，插件机制完善

* 【loader】用于加载某些资源文件。因为webpack本身只能打包common.js规范的js文件，对于其他资源如css，img等，是没有办法加载的，这时就需要对应的loader将资源转化，从而进行加载。
* 【plugin】用于扩展webpack的功能。不同于loader，plugin的功能更加丰富，比如压缩打包，优化，不只局限于资源的加载。
* css-loader: 加载.css文件
* style-loader:使用`<style>`将css-loader内部样式注入到我们的HTML页面


# vite


*   配置：Vite默认支持零配置，这意味着大多数情况下你不需要手动配置。但是如果需要自定义配置，你可以在项目根目录创建一个vite.config.js文件，并在其中设置你的配置选项


-    基于ESM的Dev server      当 import 模块时，浏览器就会下载被导入的模块。先启动开发服务器，当代码执行到模块加载时再请求对应模块的文件,本质上实现了动态加载
-    基于ESM 的 HMR 热更新     主要是通过WebSocket创建浏览器和服务器的通信监听文件的改变，当文件被修改时，服务端发送消息通知客户端修改相应的代码，客户端对应不同的文件进行不同的操作的更新。
-    基于esbuild的依赖预编译优化   通过预构建 lodash-es 成为一个模块，也就只需要一个 HTTP
         *    esbuild则选择使用 Go 语言编写将语言转为机器语言，在启动的时候直接执行即可，在 CPU 密集场景下，Go 更具性能优势
         *    Go多线程又是
-   基于Rollup的 Plugins   同时Vite也基于Rollup plugins机制提供了强大的插件API。目前和 Vite 兼容或者内置的插件，
    

优点：
*   快速的冷启动: 采用No Bundle和esbuild预构建，速度远快于Webpack
*   高效的热更新：基于ESM实现，同时利用HTTP头来加速整个页面的重新加载，增加缓存策略
*   真正的按需加载: 基于浏览器ESM的支持，实现真正的按需加载

缺点：
*   前Vite的生态不如Webapck，不过我觉得生态也只时间问题
*   生产环境由于esbuild对css和代码分割不友好使用Rollup进行打包

# 区别

* webpack是一个模块打包器，强调的是一个前端模块化方案，更侧重模块打包，我们可以把开发中的所有资源都看成是模块，通过loader和plugin对资源进行处理。
* gulp是一个前端自动化构建工具，强调的是前端开发的工作流程，可以通过配置一系列的task，第一task处理的事情（如代码压缩，合并，编译以及浏览器实时更新等）。然后定义这些执行顺序，来让glup执行这些task，从而构建项目的整个开发流程。自动化构建工具并不能把所有的模块打包到一起，也不能构建不同模块之间的依赖关系。
*  vite其核心原理是利用浏览器现在已经支持ES6的import,碰见import就会发送一个HTTP请求去加载文件，Vite启动一个 koa 服务器拦截这些请求，并在后端进行相应的处理将项目中使用的文件通过简单的分解与整合，然后再以ESM格式返回返回给浏览器。Vite整个过程中没有对文件进行打包编译，做到了真正的按需加载，所以其运行速度比原始的webpack开发编译速度快出许多