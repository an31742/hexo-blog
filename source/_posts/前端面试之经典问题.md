---
title: 前端面试之经典问题
date: 2022-08-17 21:09:52
tags: 前端面试
---


### 0.1 + 0.2 === 0.3 嘛？为什么？

JavaScirpt通过使用Number数字类型来表示数字(整数或者浮点数)，遵循IEEE754标准，通过64位来表示一个数字（1+11+52）

* 1符号位，0表示正数，1表示负数s
* 11指数位（e）
* 52尾数，小数部分（有效数字）

最大安全数：NumberMAX_SAFE_INTEGER=Math.pow(2,53)-1,

转换成整数就是16位，所以0.1===0.1,是因为通过 toPrecision(16) 去有效位之后，两者是相等的。

在两数相加是，会先转化成为二进制，0.1和0.2转化成二进制的时候尾数会发生无线循环，然后进行对阶运算，js引擎对二进制进行截断，所以造成精度丢失。

##### 精度缺失可能出现在进阶转换和对阶运算

```js
//解决办法
parseFloat（（0.1+0.2）.precision（12））  //0.3

```
### 从输入url到渲染出页面的整个过程

#### 加载过程
* NDS域名解析 解析域名到IP地址
* 浏览器根据IP地址向服雾器发送请求
* 浏览器处理http请求并返回给浏览器

#### 渲染过程
* 根据html生成DOM树
* 根据css生成cssOM
* 将DOM树和cssom树整合成render树

#### 渲染过程2
* 根据render渲染页面
* 遇到script暂停渲染优先加载js代码

### typeof一个函数返回的是什么

typeof 一个函数返回是是function

### 事件捕获

由外向内

### http状态码

* 301永久重定向，从a永久跳转到b
* 302临时重定向
* 304资源未改变

### 浏览器存储
cookie 
* document.cookie修改 借用本地存储 最大4kb   请求需要发送到服务端增加请求的数据量
* localStorage 最大是5m  setItem 和 getItem  永久储存
* sessionStorage  最大是5M setItem 和 getItem 关闭会话就会删除

### key的作用
*   在 Vue.js 中，key 的作用是为 Vue 的虚拟 DOM 算法提供一个唯一的标识，以便它能够跟踪每个节点的变化，并作出相应的更新。这就是 key 的主要作用。它也可以帮助 Vue 在重新排列元素时保持状态或避免重新渲染。例如，如果您渲染一个列表，并在用户点击按钮时将其重新排列，您可以使用 key 来确保 Vue 可以正确地跟踪每个元素。

### $nexttick的原理

*   Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。$nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM。**

### props传一个对象，$emit可以改变吗
*   可以的。在 Vue.js 中，父组件可以通过在子组件上定义 `props` 属性来传递数据给子组件。然后，子组件可以通过触发自定义事件来向父组件传递数据


### var a=1，function tset(a){a=2} console.log(a) //1

### instanceof原理
*   instanceof`是一种JavaScript运算符，用于检测构造函数的原型属性是否存在于某个实例对象的原型链上。
换句话说，`instanceof`运算符用于检查某个对象是否是某个特定类型的实例，比如检查一个对象是否是一个数组
### 继承

### $set如何修改数组和对象
*   首先，判断在非生产环境，传入的target如果是undefined、null或是原始类型，则直接跑出错误。
其次，如果判断target如果是个数组，并且key是索引的话，那么就取当前数组长度与key这两者的最大值作为数组的新长度，然后使用数组的splice方法将传入的索引key对应的val值添加进数组。Array类型数据的变化侦测方式时说过，数组的splice方法已经被我们创建的拦截器重写了，也就是说，当使用splice方法向数组内添加元素时，该元素会自动被变成响应式的。

*  接下来，如果传入的target不是数组，那就当作是对象来处理。首先判断传入的key是否已经存在于target中，如果存在，表明这次操作不是新增属性，而是对已有的属性进行简单的修改值，那么就只修改属性值即可，接下来获取到traget的__ob__属性，我们说过，该属性是否为true标志着target是否为响应式对象，接着判断如果tragte是 Vue 实例，或者是 Vue 实例的根数据对象，则抛出警告并退出程序，接着判断如果ob属性为false，那么表明target不是一个响应式对象，那么我们只需简单给它添加上新的属性，不用将新属性转化成响应式，最后，如果target是对象，并且是响应式，那么就调用defineReactive方法将新属性值添加到target上，defineReactive方会将新属性添加完之后并将其转化成响应式，最后通知依赖更新


参考文献 https://blog.csdn.net/weixin_42038290/article/details/114700728?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-12-114700728-blog-122427044.235^v38^pc_relevant_sort&spm=1001.2101.3001.4242.7&utm_relevant_index=15
### export和export define的区别
*   export 用于导出模块中的多个变量或函数，在导入模块时需要使用大括号括起来，并使用相同的名称来引用这些变量或函数。
*   export default 用于导出模块中的默认变量或函数，在导入模块时可以使用任意名称来引用这个变量或函数。


### 理解diff算法  
*   diff 算法是一种用于比较两个序列的不同之处的算法。它常用于计算文件或者文本的差异，并且能够快速地找到两个序列之间的相似部分。diff 算法通常与 patch 算法配合使用，来快速地将一个序列转换为另一个序列。

*   diff 算法通常采用动态规划的方法来计算两个序列之间的差异。它会比较两个序列中每个元素的相似度，并且从这些相似度中找到最优的匹配方式。diff 算法通常能够计算出两个序列之间的最小编辑距离，并且能够返回一个编辑路径，指示如何将一个序列转换为另一个序列。

*   diff 算法的时间复杂度通常为 O(n^2)，其中 n 是两个序列的长度。它的空间复杂度也是 O(n^2)。 diff 算法的性能可能会受到序列的相似度的影响，对于非常相似的序列，diff 算法的性能可能会比较差

### 什么是单向数据流
*   所有的 props 都遵循着单向绑定原则，props 因父组件的更新而变化，自然地将新的状态向下流往子组件，而不会逆向传递。这避免了子组件意外修改父组件的状态的情况，不然应用的数据流将很容易变得混乱而难以理解


### 单向数据流为什么不能改对象 / 数组类型的 props
*  当对象或数组作为 props 被传入时，虽然子组件无法更改 props 绑定，但仍然可以更改对象或数组内部的值。这是因为 JavaScript 的对象和数组是按引用传递，而对 Vue 来说，禁止这样的改动，虽然可能生效，但有很大的性能损耗，比较得不偿失。

*  这种更改的主要缺陷是它允许了子组件以某种不明显的方式影响父组件的状态，可能会使数据流在将来变得更难以理解。在最佳实践中，你应该尽可能避免这样的更改，除非父子组件在设计上本来就需要紧密耦合。在大多数场景下，子组件应该抛出一个事件来通知父组件做出改变