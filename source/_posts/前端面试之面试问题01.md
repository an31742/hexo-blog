---
title: 前端面试之基础问题
date: 2022-06-14 18:33:00
tags:
- 前端面试
categories:
- 面试
---

# 面试题

## 0.1 + 0.2 === 0.3 嘛？为什么？

JavaScirpt通过使用Number数字类型来表示数字(整数或者浮点数)，遵循IEEE754标准，通过64位来表示一个数字（1+11+52）

* 1符号位，0表示正数，1表示负数s
* 11指数位（e）
* 52尾数，小数部分（有效数字）

最大安全数：NumberMAX_SAFE_INTEGER=Math.pow(2,53)-1,

转换成整数就是16位，所以0.1===0.1,是因为通过 toPrecision(16) 去有效位之后，两者是相等的。

在两数相加是，会先转化成为二进制，0.1和0.2转化成二进制的时候尾数会发生无线循环，然后进行对阶运算，js引擎对二进制进行截断，所以造成精度丢失。

##### 精度缺失可能出现在进阶转换和对阶运算

````js
//解决办法
parseFloat（（0.1+0.2）.precision（12））  //0.3
````





### 参考链接

- https://juejin.im/post/5b90e00e6fb9a05cf9080dff



## JS 数据类型

 基本类型：Number、Boolean、String、null、undefined、symbol（ES6 新增的），BigInt（ES2020） 引用类型：Object，对象子类型（Array，Function） 





## JS 整数是怎么表示的？

*  通过 Number 类型来表示，遵循 IEEE754 标准，通过 64 位来表示一个数字，（1 + 11 + 52），最大安全数字是 Math.pow(2, 53) - 1，对于 16 位十进制。（符号位 + 指数位 + 小数部分有效位） 



## Number() 的存储空间是多大？如果后台发送了一个超过最大自己的数字怎么办

 Math.pow(2, 53) ，53 为有效数字，会发生截断，等于 JS 能支持的最大数字。 










## 事件是如何实现的

基于发布订阅模式，就是在浏览器加载的时候会读取事件相关的代码，但是只有实际等到具体的事件触发的时候才会执行。

比如点击按钮，这是个事件（Event），而负责处理事件的代码段通常被称为事件处理程序（Event Handler），也就是「启动对话框的显示」这个动作。

在 Web 端，我们常见的就是 DOM 事件：

- DOM0 级事件，直接在 html 元素上绑定 on-event，比如 onclick，取消的话，dom.onclick = null，同一个事件只能有一个处理程序，后面的会覆盖前面的。
- DOM2 级事件，通过 addEventListener 注册事件，通过 removeEventListener 来删除事件，一个事件可以有多个事件处理程序，按顺序执行，捕获事件和冒泡事件
- DOM3级事件，增加了事件类型，比如 UI 事件，焦点事件，鼠标事件

### 参考链接

- https://zhuanlan.zhihu.com/p/73091706







## `symbol` 有什么用处

可以用来表示一个独一无二的变量防止命名冲突。但是面试官问还有吗？我没想出其他的用处就直接答我不知道了，还可以利用 `symbol` 不会被常规的方法（除了 `Object.getOwnPropertySymbols` 外）遍历到，所以可以用来模拟私有变量。

主要用来提供遍历接口，布置了 `symbol.iterator` 的对象才可以使用 `for···of` 循环，可以统一处理数据结构。调用之后回返回一个遍历器对象，包含有一个 next 方法，使用 next 方法后有两个返回值 value 和 done 分别表示函数当前执行位置的值和是否遍历完毕。

Symbol.for() 可以在全局访问 symbol












### 字符串和数字

- "+" 操作符，如果有一个为字符串，那么都转化到字符串然后执行字符串拼接
- "-" 操作符，转换为数字，相减 (-a, a * 1 a/1) 都能进行隐式强制类型转换

```
[] + {} 和 {} + []
```

### 布尔值到数字

- 1 + true = 2
- 1 + false = 1

### 转换为布尔值

- for 中第二个
- while
- if
- 三元表达式
- || （逻辑或） && （逻辑与）左边的操作数

### 符号

- 不能被转换为数字
- 能被转换为布尔值（都是 true）
- 可以被转换成字符串 "Symbol(cool)"


#### 字符串与数字

转换为数字然后比较

#### 其他类型与布尔类型

- 先把布尔类型转换为数字，然后继续进行比较

#### 对象与非对象

- 执行对象的 ToPrimitive(对象）然后继续进行比较

#### 假值列表

- undefined
- null
- false
- +0, -0, NaN
- ""

## 了解 this 嘛，bind，call，apply 具体指什么

它们都是函数的方法

`call: Array.prototype.call(this, args1, args2])``apply: Array.prototype.apply(this, [args1, args2])` ：ES6 之前用来展开数组调用, `foo.appy(null, [])`，ES6 之后使用 ... 操作符

- New 绑定 > 显示绑定 > 隐式绑定 > 默认绑定
- 如果需要使用 bind 的柯里化和 apply 的数组解构，绑定到 null，尽可能使用 Object.create(null) 创建一个 DMZ 对象

四条规则：

- 默认绑定，没有其他修饰（bind、apply、call)，在非严格模式下定义指向全局对象，在严格模式下定义指向 undefined    

    ~~~js
     function foo() {
       console.log(this.a); 
     }

     var a = 2;
     foo();
   ~~~

* 隐式绑定：调用位置是否有上下文对象，或者是否被某个对象拥有或者包含，那么隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。而且，对象属性链只有上一层或者说最后一层在调用位置中起作用 

  ~~~js
    function foo() {
      console.log(this.a);
    }

    var obj = {
      a: 2,
      foo: foo,
    }
  
    obj.foo(); // 2
  ~~~

*  显示绑定：通过在函数上运行 call 和 apply ，来显示的绑定 this 

 ~~~js
   function foo() {
     console.log(this.a);
   }

   var obj = {
     a: 2
   };

   foo.call(obj)
 ~~~

* 显示绑定之硬绑定

  ```js
      unction foo(something) {
        console.log(this.a, something);
        
        return this.a + something;
      }
  
      function bind(fn, obj) {
        return function() {
          return fn.apply(obj, arguments);
        };
      }
  
      var obj = {
        a: 2
      }
  
      var bar = bind(foo, obj);
  ```

New 绑定，new 调用函数会创建一个全新的对象，并将这个对象绑定到函数调用的 this。

- New 绑定时，如果是 new 一个硬绑定函数，那么会用 new 新建的对象替换这个硬绑定 this，

~~~js

function foo(a) {
  this.a = a;
}

var bar = new foo(2);
console.log(bar.a)
~~~



## `setTimeout(fn, 0)`多久才执行，Event Loop

setTimeout 按照顺序放到队列里面，然后等待函数调用栈清空之后才开始执行，而这些操作进入队列的顺序，则由设定的延迟时间来决定






## js脚本加载问题，async、defer问题

- 如果依赖其他脚本和 DOM 结果，使用 defer
- 如果与 DOM 和其他脚本依赖不强时，使用 async

## 如何判断一个对象是不是空对象？

Object.keys(obj).length === 0

## <script src=’xxx’ ’xxx’/>外部js文件先加载还是onload先执行，为什么？

onload 是所以加载完成之后执行的

## 怎么加事件监听，两种

onclick 和 addEventListener

## 事件传播机制（事件流）

冒泡和捕获


## 问：用过 TypeScript 吗？它的作用是什么？

为 JS 添加类型支持，以及提供最新版的 ES 语法的支持，是的利于团队协作和排错，开发大型项目


## 问：数组能够调用的函数有那些？

- push
- pop
- splice
- slice
- shift
- unshift
- sort
- find
- findIndex
- map/filter/reduce 等函数式编程方法
- 还有一些原型链上的方法：toString/valudOf



### 参考资料

- https://segmentfault.com/a/1190000015162781

## 知道 ES6 的 Class 嘛？Static 关键字有了解嘛

为这个类的函数对象直接添加方法，而不是加在这个函数对象的原型对象上

## 事件循环机制 （Event Loop）

事件循环机制从整体上告诉了我们 JavaScript 代码的执行顺序`Event Loop`即事件循环，是指浏览器或`Node`的一种解决`javaScript`单线程运行时不会阻塞的一种机制，也就是我们经常使用**异步**的原理。

先执行宏任务队列，然后执行微任务队列，然后开始下一轮事件循环，继续先执行宏任务队列，再执行微任务队列。

- 宏任务：script/setTimeout/setInterval/setImmediate/ I/O / UI Rendering
- 微任务：process.nextTick()/Promise

上诉的 setTimeout 和 setInterval 等都是任务源，真正进入任务队列的是他们分发的任务。

### 优先级

- setTimeout = setInterval 一个队列
- setTimeout > setImmediate
- process.nextTick > Promise

```js
for (const macroTask of macroTaskQueue) {                handleMacroTask();    
for (const microTask of microTaskQueue) {       handleMicroTask(microTask);   
   }}
```

### 参考链接

- https://juejin.im/post/59e85eebf265da430d571f89

## 手写题：数组扁平化

```
function flatten(arr) {  let result = [];  for (let i = 0; i < arr.length; i++) {    if (Array.isArray(arr[i])) {      result = result.concat(flatten(arr[i]));    } else {      result = result.concat(arr[i]);    }  }  return result;}const a = [1, [2, [3, 4]]];console.log(flatten(a));
```

## 手写题：实现柯里化

预先设置一些参数

柯里化是什么：是指这样一个函数，它接收函数 A，并且能返回一个新的函数，这个新的函数能够处理函数 A 的剩余参数

```
function createCurry(func, args) {  var argity = func.length;  var args = args || [];    return function () {    var _args = [].slice.apply(arguments);    args.push(..._args);        if (args.length < argity) {      return createCurry.call(this, func, args);    }        return func.apply(this, args);  }}
```


## 问：let 闭包

let 会产生临时性死区，在当前的执行上下文中，会进行变量提升，但是未被初始化，所以在执行上下文执行阶段，执行代码如果还没有执行到变量赋值，就引用此变量就会报错，此变量未初始化。

## 问：变量提升

函数在运行的时候，会首先创建执行上下文，然后将执行上下文入栈，然后当此执行上下文处于栈顶时，开始运行执行上下文。

在创建执行上下文的过程中会做三件事：创建变量对象，创建作用域链，确定 this 指向，其中创建变量对象的过程中，首先会为 arguments 创建一个属性，值为 arguments，然后会扫码 function 函数声明，创建一个同名属性，值为函数的引用，接着会扫码 var 变量声明，创建一个同名属性，值为 undefined，这就是变量提升。

## instance 如何使用

左边可以是任意值，右边只能是函数

```js
'hello tuture' instanceof String // false
```

## vue2和vue3有什么不同
1. api不同，
2. vue3使用render函数
3. vue3没有过滤器
4. setup 函数
5. 生命周期，

## vue3响应式原理比vue2有什么优点
 Object.defineProperty 无法监控到数组下标的变化
 Object.defineProperty 只能劫持对象的属性

## keep-alive中actived和beactived在什么时候触发
activated 当组件被激活（使用）的时候触发 可以简单理解为进入这个页面的时候触发
deactivated 当组件不被使用（inactive状态）的时候触发 可以简单理解为离开这个页面的时候触
 
## 参考资料
  https://segmentfault.com/a/1190000040006753 
## 事件队列
定义：是一个不断运行的进程，它协调调用堆栈和回调队列之间的任务以实现并发。


## 参考资料

- https://juejin.im/post/5d79ccf85188254bf34fd9d1
- [https://mp.weixin.qq.com/s/pw5lfFeNagmjFj45ygl2dQ](https://mp.weixin.qq.com/s?__biz=MzU3OTg0Njc0MA==&mid=2247484284&idx=1&sn=52ba03c9fa0cf65c89737b75cb0e3f26&scene=21#wechat_redirect)
- [https://mp.weixin.qq.com/s/bHclDpsGdfaZQT8u9VRAAw](https://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&mid=2247485124&idx=1&sn=5c199362635493957d53d37102457dc9&scene=21#wechat_redirect)
- https://www.jianshu.com/p/cd3fee40ef59